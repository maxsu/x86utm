# x86utm
<b>A Universal Turing Machine (UTM) having the x86 language as its TM description language.</b>

This x86 based Universal Turing Machine (UTM) directly executes COFF object files generated by the Microsoft "C" compiler.

There are two restrictions on the "C" code that can be executed in this virtual machine:<br>
(1) All global data must be initialized.<br>
(2) No library functions can be called.<br>

The intent is to study theory of computation problems such as the Halting Problem in a high level language such as "C". 
It can be shown that every "C" and x86 program that terminates has a Turing Machine equivalent. 

<b>The UTM environment is like a tiny little operating system here are its only functions:</b>

// allocates memory from Heap_Space.<br>
<b>[A] u32* Allocate(u32 size); </b>

// executes a slave UTM in single step debug mode<br>
<b>[B] u32 Debug_Step(u32* master_state, u32* slave_state);</b>

// Saves the execution state of a UTM to state_data<br>
<b>[C] u32 Save_State(u32* state_data);  </b>

// Loads the execution state of a UTM from state_data<br>
<b>[D] u32 Load_State(u32* state_data);  </b>

When a UTM is running the execution trace of each assembly language instruction / operating system function call is written to stdout. 

After each Debug_Step() virtual machine instruction is executed the Master UTM can examine the machine state of the Slave UTM.

The recursion depth of UTMs executing other UTMs in Debug-Step mode is of arbitrary depth. 
